1
Components
	Encapsulates the template, data, and behavior of a view
Directives
	To modify DOM elements and/or extend their behaviour
Routers
	Responsible for navigation
Services
	Class that encapsulates non-UI logic. 
2
Components
	import {Component} from 'angular2/core'
Creating Components
	@Component({selector:'appcomponent'})
	export class AppComponent{}
Using Components
	import {AppComponent} from './app/app.component'
	@Component({
		template:`<appcomponent></appcomponent>`,
		directives:[AppComponent]})
Templates
	template:`<div></div>`
	//note that use template in body does not create additional elements
	template:`<div><template *ngFor="#item of items></template></div>`
	//note that this uses absolute path
	templateUrl:'app/template.html'
	
Creating Services
	export class AppService{getItems(){return ["a","b","c"];}}
Using Services with Dependency Injection
	import {ItemsService} from './app/app.service'
	@Component({
		template:`<ul><li *ngFor="#item of items"></li></ul>`,
		providers:[AppService]})
	export class AppComponent{
		items;
		constructor(itemsService: AppService){this.items = itemsService.getItems();}}
Directives
	import {Directive, ElementRef,Renderer} from 'angular2/core'
Creating Directives
	@Directive({
		selector:'[autoGrow]',
		//note that the square brackets make selector into an attribute selector, not an element selector
		host:{'(focus)':'onFocus()'}})
	export class AutoGrowDirective{
		constructor(private _el:ElementRef, private _renderer:Renderer){}
		onFocus(){this._renderer.setElementStyle(this._el.nativeElement, 'width', '200'}}
Using Directives
	@Component({
		template:`<input autoGrow/>`,
		directives:[AutoGrowDirective]})
3
Property Binding
	@Component({<img [src]="someVar"/>})
	<img bind-src="someVar"
Expression Binding(slower, possibly leaves binding expression on screen)
	<img src="{{someExpression involving someVar}}"
	export class AppComponent{someVar = "www.image.com";}
Class Binding
	<li [class.someClass]="someVar"/>
Style Binding
	<button [style.background]="someVar"/>
Event Binding
	<button (click)="someFunc($event)"/>
	export class AppComponent{someFunc(e){}}
Two-way Binding
	//note that ngModel has hardcoded directives for [value] and (input)
	//essentially being <input type="text" [value]="someVar" (input)="someVar = $event.target.value"
	<input type="text" [(ngModel)]="someVar"/>
	<input type="text" bindon-ngModel="someVar"/>
4
Input
	import {Input} from 'angular2/core'
Input Property
	export class AppComponent{
		@Input("someAlias") someVar = false;}
Using Input
	<appcomponent [someAlias]="true"></appcomponent>
Output
	import {Output} from 'angular2/core'
Output Property
	export class AppComponent{
		@Output("someAlias") someEvent = new EventEmitter();
		onClick(){this.someEvent.emit();}}
Using Output
	<appcomponent (someAlias)="someFunc()"></appcomponent>
5
ngIf
	<i class="loading" *ngIf="!isActive"></i>
ngSwitch
	<div [ngSwitch]="somevar">
		<div *ngSwitchWhen="'a'" ngSwitchDefault></div>
		<div *ngSwitchWhen="'b'"></div>
	</div>
ngFor
	<ul><li *ngFor="#item of items"></li>
Asterisk
	treat current element as a template
	<li *ngFor="#item of items"></li>
	example without asterisk
	<template ngFor="#item of items">
		<li></li>
	</template>
Pipes
	<div>{{someVar | uppercase}}</div>
Custom Pipes
	import {Pipe, PipeTransform} from 'angular2/core';
	@Pipe({name:'custompipe'})
	export class SummaryPipe implements PipeTransform{
		transform(value:string, args: string[]){
			return "";
		}
	}
Using Custom Pipes
	import {SummaryPipe} from './app/summarypipe'
	@Component({
		template:`<div>{{someVar | custompipe}}`,
		pipes:[SummaryPipe]})
ngClass
	<div
		[ngClass]="{
			'glyphicon-star-empty':!isFavorite,
			'glyphicon-star':isFavorite
		}></div>
ngStyle
	<div
		[ngStyle]="{
			'backgroundColor':isFavorite?'red':'blue',
			'color':isFavorite?'red','blue'
		}></div>
Elvis Operator
	null subproperty operator
	<div>{{task?.assignee?.role?.name}}</div>
ng-content Element
	insertion points for external data
	@Component({
		selector:'appcomponent',
		template:`
			<div>
				<ng-content></ng-content>
			</div>`})
	export class AppComponent{}
	--
	import {AppComponent} from './app/app.component'
	@Component({template:`<appcomponent>Insert This Text</appcomponent>`,
	directives:[AppComponent]})
6
Template-driven Form
Control
ControlGroup
ngControl
Validation Errors
ngForm
Disabling Submit Button
7
Create Control Explicitly: Model-driven form
	import {ControlGroup,Control} from 'angular2/common'
	@Component({
		template:`
			<form [ngFormModel]="formVar" >
				<input ngControl="comment"/>
			</form>`})
	export class FormComponent{
		formVar = new ControlGroup({
			comment: new Control()
		});
	}
FormBuilder
	more compact, allows injection
	import {FormBuilder} from 'angular2/common'
	export class ContactComponent{
		formVar;
		constructor(fb:FormBuilder}{this.formVar = fb.group({comment:[]});}
	}
Validation
	import {Validators} from 'angular2/common'
	@Component({
		template:`
			<form [ngFormModel]="formVar" >
				<input ngControl="comment"/>
			</form>`})
	export class FormComponent{
		formVar = new ControlGroup({
			comment: new Control('defaultValue',Validators.required)
		});
	}
Valid Errors
	@Component({
		template:`
			<form [ngFormModel]="formVar" >
				<input #="nametemp"/>
				<div *ngIf="!nametemp.valid">Username is invalid</div>
			</form>`})
	export class FormComponent{
		formVar = new ControlGroup({
			comment: new Control('defaultValue',Validators.required)
		});
	}
Custom Validation
	--validator.component
	export class UsernameValidators{
		static isEmpty(someControl:Control){
			if(someControl){
				return{isEmpty:true};
			}
			return null;
		}
	}
	--app.component
	import {UsernameValidators} from './validator.component'
	export class FormComponent{
		formVar = new ControlGroup({
			comment: new Control('',Validators.compose([UsernameValidators.isEmpty]))
		});
Async Validation
	--validator.component
	export class UsernameValidators{
		static isUnique(someControl:Control){
			return new Promise((resolve,reject)=>{
				//server call with callback function that uses "resolve"
				setTimeout(function(){
					if(control.value =="test"){
						resolve({isUnique:true});
					else
						resolve({isUnique:false});
					}
				},1000)
			});
		}
	}
	--app.component
	import {UsernameValidators} from './validator.component'
	export class FormComponent{
		formVar = new ControlGroup({
			//note that this is the third parameter for async
			comment: new Control('',,UsernameValidators.isUnique)
		});
Loader Image
	<input #somevar="ngForm"/>
	<div *ngIf="somevar.control.pending">Checking...</div>
Validating Upon Form Submit
	<form>
		<div *ngIf="form.errors.invalidForm" >Invalid form</div>
	<form>
	
	export class FormComponent{
		onSubmit(){
			var result = authService.login(this.form.value);
			this.form.setErrors({invalidForm:true});
		}
8 Rx
Callback Hell
	nested callbacks
	harder to read than flat code that essentially "awaits" last line
	parallel, series, and combinations not handled. everything is done as a waterfall
	have to handle errors in each one
Creating Observables
	Observable.empty()
		returns an empty observable that terminates normally
	Observable.never()
		returns an empty observable that never terminates
	Observable.throw()
		returns an empty observable that throws an error
	Observable.from
	Observable.fromPromise(somePromise)
	Observable.fromArray([1, 2, 3])
		returns an observable with the same number of items as base
	Observable.fromEvent(_form, "keyup");
	Observable.of([1, 2, 3])
		returns an observable of one item
	Observable.range(1, 5)
		returns an observable with five items
	DOM Events
	Web Sockets
	AJAX
Transforming Observables
	.map(x=>x*2)
		transform each item
	.flatMap(x=>return Observable.fromPromise())
		if map function uses async function, it will return an observable for each value
		.map(x=>Observable.timer(100))
		so you would have to merge all the items following two statements do the same thing
		.map(x=>Observable.timer(100).mergeAll())
		.flatmap(x=>Observable.timer(100))
Filtering Observables
	.debounce(300)
		throttle calling for specificed milliseconds
	.distinct()
		emits items that have not been emitted before
	.distinctUntilChanged()
		emits items that are different from the previous item
	.elementAt(3)
		emit only item n emitted by an Observable
	.filter(x=>x ==3)
		emit only those items from an Observable that pass a predicate test
	.ignoreElements()
		don't emit elements, only the completed signal
	.last()
		emit only the last item emitted by an Observable
	.skip(3)
		skip n emissions
	.take(3)
		take n emissions then complete

Combining Observables
	Observable.forkJoin(
		this._gitHubService.getUser(this.username), 
		this._gitHubService.getFollowers(this.username)
	)
	.subscribe(
		res => {
			this.user = res[0];
			this.followers = res[1];
		}, 
		null, 
		() => { this.isLoading = false; })
Cancelling Subscriptions
	var subscription = keyups.subscribe(data=>console.log(data));
	subscription.unsubscribe();
Error Handling
Importing Operators
9
RESTful API
	Representational state transfer: GET, PUT, POST, DELETE
	stateless server: same call gets same data
get Data
	import {Http} from 'angular2/http';
    getUser(username){
		return this._http.get(this._baseUrl + username)
			.map(res => res.json());
    }
send Data
	createPost(post){
		return this._http.post(this._baseUrl,JSON.stringify(post))
			.map(res => res.json());
	}
Component Lifecycle Hooks
	import {Component, OnInit} from 'angular2/core';
	export class GitHubProfileComponent implements OnInit {
		ngOnInit(){
			this._postService.getPosts().subscribe(x=>console.log(x));
		}
	}
	OnDestroy
	DoCheck
	OnChanges
	AfterContentInit
	AfterContentChecked
	AfterViewInit
	AfterViewChecked
Static Type Checking
	used for intellisense
	export interface Post{
		userId:number;
		id?:number
	}
	getPosts():Observable<Post[]>{
		return this._http.get(this._baseUrl + username)
			.map(res => res.json());
	}
Promises
	.map()
	.toPromise();
CORS/JSONP
	JSONP only supports get requests
	providers:[JSONP_PROVIDERS]
	export class PostService{
		constructor(private _jsonp:Jsonp){}
		getPosts(){return this._jsonp.get("url");}
	}
	CORS has to enable your domain from their server
	var headers = new Headers({"access-control-request-method":"POST"});
	var optinons = new RequestOptions({headers:headers});
	this._http.get("url", options);
10
Enabling Routing
	--index.html
	<head>
		<base href="/">
	</head>
	<script src = "node_modules/angular2/bundles/router.dev.js/>
	--boot.ts
	import {ROUTER_PROVIDERS} from 'angular2/router'
	bootstrap(AppComponent, [ROUTER_PROVIDERS]}
Configuring Routes
	--app.component.ts
	@RouteConfig([
		{ path: '/', name: 'Home', component: HomeComponent },
		{ path: '/archives/:year/:month', name: 'Archives', component: ArchivesComponent },
		{ path: '/*other', name: 'Other', redirectTo: ['Home'] }
	])
Router Outlet
	--app.component.ts
	@Component({
		selector: 'my-app',
		template: `
			<router-outlet></router-outlet>
		`,
		directives: [ROUTER_DIRECTIVES]
	})
Adding Links
	@Component({
		template: `
			<h1>Home Page</h1>
			<ul>
				<li *ngFor="#archive of archives">
					<a [routerLink]="['Archives', { year: archive.year, month: archive.month }]">
						{{ archive.year }}/{{ archive.month }}
					</a>
				</li>
			</ul>
		`,
		directives: [RouterLink]
	})
Route Parameters
	export class ArchivesComponent {
		year: number;
		month: number;
		
		constructor(private _routeParams: RouteParams){
			this.year = parseInt(_routeParams.get("year"));
			this.month = parseInt(_routeParams.get("month"));
		}
	}
Imperative Navigation
	import {Router} from 'angular2/router';
	export class ContactComponent{
		constructor(private _router:Router}{}
		onSubmit(form){this._router.navigate(['Albums']);}
	}
Implementing Dirty Checking
	CanDeactivate runs before navigating away from current page
	import {Router, CanDeactivate} from 'angular2/router';
	export class ContactComponent implements CanDeactivate{
		formVar;
		constructor(fb:FormBuilder, private _router:Router}{this.formVar = fb.group({name:[],comment:[]});}
		onSubmit(form){this._router.navigate(['Albums']);}
		routerCanDeactivate(next,previous){
			if(this.formVar.dirty)
				return confirm("Are you sure");
			return true;
		}
	}
Structuring Large Apps
	organize into feature areas ie. /app/subdomains/parameters
	keep shared components in /shared
	/events/... the three dots are an incomplete route
	on the EventsComponent you will have finished routes or more ...
	@RouteConfig([
		{
			path:'/events/...',
			name:'Events',
			component:'EventsComponent'
		},
		{
			path:'/hangouts/...',
			name:'Hangouts',
			component:'HangoutsComponent'
		}
	])